sload time.maude 

fmod BPMN is 
  sorts Gateway Resource Process Node Id Flow Token .
endfm

view Resource from TRIV to BPMN is
  sort Elt to Resource .
endv

view Token from TRIV to BPMN is
  sort Elt to Token .
endv

view Id from TRIV to BPMN is
  sort Elt to Id .
endv

view Node from TRIV to BPMN is
  sort Elt to Node .
endv

view Flow from TRIV to BPMN is
  sort Elt to Flow .
endv

mod BPMN-SEM is
  inc CONFIGURATION .
  pr POSRAT-TIME-DOMAIN-WITH-INF .
  pr BPMN .
  pr STRING .
  pr SET{Resource} .
  pr SET{Flow} .
  pr SET{Token} .
  pr SET{Id} .
  pr SET{Node} .

  subsort Process < Cid .

  *** class Process | nodes: Set{Node}, flows: Set{Flow}, tokens: Set{Token}, gtime: Time, resources: Set{Resource} .
  op Process : -> Process .
  op nodes:_ : Set{Node} -> Attribute [gather (&)] .
  op flows:_ : Set{Flow} -> Attribute [gather (&)] .
  op tokens:_ : Set{Token} -> Attribute [gather (&)] .
  op resources:_ : Set{Resource} -> Attribute [gather (&)] .
  op gtime:_ : Time -> Attribute [gather (&)] .

  op id : String -> Id [ctor] .

  op exclusive : -> Gateway [ctor] .
  op parallel : -> Gateway [ctor] .
  
  *** Tipos de nodo
  *** start(Id nodo, Id flujo salida)
  op start : Id Id -> Node [ctor] .
  *** end(Id nodo, Id flujo de entrada)
  op end : Id Id -> Node [ctor] .
  *** task(Id nodo, Nombre de la tarea, Id flujo entrada, Id flujo salida, duración, conjunto de recursos)
  op task : Id String Id Id Time Set{Id} -> Node [ctor] .
  *** split(Id nodo, tipo puerta, Id flujo entrada, Ids flujos salida)
  op split : Id Gateway Id Set{Id} -> Node [ctor] .
  *** merge(Id nodo, tipo puerta, Ids flujos entrada, Id flujo salida)
  op merge : Id Gateway Set{Id} Id -> Node [ctor] .
  
  *** resource(Id recurso, Cantidad, Disponible)
  op resource : Id Nat Nat -> Resource [ctor] .
  *** flow(Id flujo, Duración)
  op flow : Id Time -> Flow [ctor] .
  *** token(Id token, Temporizador)
  op token : Id Time -> Token [ctor] . 

  op delta : Set{Token} Time -> Set{Token} .
  op mte : Set{Token} -> TimeInf .

  vars GTIME T DURACION DURACION' : Time .
  vars ID ID' IDIN IDOUT IDSPLIT IDMERGE : Id .
  vars IDINSET IDOUTSET IDSET : Set{Id} .
  var O : Oid .
  var STRING : String .
  var NODESET : Set{Node} .
  var FLOWSET : Set{Flow} .
  var TOKENSET : Set{Token} .
  vars RESOURCESET RESOURCESET' : Set{Resource} .
  var GATEWAY : Gateway .
  var taskName : String .
  var Atts : AttributeSet .
  var VProcess : Process .
  vars QUANTITY AVAILABLE : Nat .

  *** Gestión del tiempo
  ceq delta((token(ID, DURACION), TOKENSET),T) = token(ID, DURACION monus T), delta(TOKENSET, T) if DURACION >= T .
  ceq delta((token(ID, DURACION), TOKENSET),T) = token(ID, zero), delta(TOKENSET, T) if DURACION < T .
  eq delta(empty, T) = empty .

  eq mte(empty) = INF .
  ceq mte((token(ID, DURACION), TOKENSET)) = mte(TOKENSET) if DURACION = zero .
  eq mte((token(ID, DURACION), TOKENSET)) = min(mte(TOKENSET), DURACION) [owise] .

  crl [tick] : 
    < O : VProcess | nodes: NODESET, flows: FLOWSET, tokens: TOKENSET, resources: RESOURCESET, gtime: GTIME, Atts > => 
    < O : VProcess | nodes: NODESET, flows: FLOWSET, tokens: delta(TOKENSET,T), resources: RESOURCESET, gtime: GTIME plus T, Atts > 
    if T := mte(TOKENSET) /\ 0 < T .

  *** Operaciones para las transiciones
  op enter-task-consume-resource : Set{Id} Set{Resource} -> Set{Resource} .
  eq enter-task-consume-resource(empty, RESOURCESET) = RESOURCESET .
  eq enter-task-consume-resource((ID,IDSET), (resource(ID, QUANTITY,AVAILABLE), RESOURCESET)) =
      enter-task-consume-resource(IDSET, RESOURCESET), resource(ID,QUANTITY, sd(AVAILABLE, 1)) .

  op enter-task-resource-available : Set{Id} Set{Resource} -> Bool .
  eq enter-task-resource-available(empty, RESOURCESET) = true .
  ceq enter-task-resource-available((ID,IDSET), (resource(ID, QUANTITY,AVAILABLE), RESOURCESET)) = 
      enter-task-resource-available(IDSET,RESOURCESET) if AVAILABLE >= 1 .
  eq enter-task-resource-available(IDSET,RESOURCESET) = false [owise] .

  op exit-task-free : Set{Id} Set{Resource} -> Set{Resource} .
  eq exit-task-free((ID,IDSET),(resource(ID,QUANTITY,AVAILABLE), RESOURCESET)) = 
     exit-task-free(IDSET,RESOURCESET), resource(ID,QUANTITY, s AVAILABLE) .
  eq exit-task-free(IDSET,RESOURCESET) = RESOURCESET [owise] .

  op split-parallel-gen-token : Set{Id} Set{Flow} -> Set{Token} .
  eq split-parallel-gen-token((ID, IDSET), (flow(ID, DURACION), FLOWSET)) = 
     split-parallel-gen-token(IDSET, FLOWSET), token(ID, DURACION) .
  eq split-parallel-gen-token(IDSET, FLOWSET) = empty [owise] .
  
  op merge-parallel-all-ready : Set{Id} Set{Token} -> Bool .
  eq merge-parallel-all-ready(empty, TOKENSET) = true .
  ceq merge-parallel-all-ready((ID, IDSET), (token(ID,DURACION), TOKENSET)) = 
      merge-parallel-all-ready(IDSET, TOKENSET) if DURACION = zero .
  eq merge-parallel-all-ready(IDSET,TOKENSET) = false [owise] .

  op merge-parallel-consume-tokens : Set{Id} Set{Token} -> Set{Token} .
  eq merge-parallel-consume-tokens(empty,TOKENSET) = TOKENSET .
  eq merge-parallel-consume-tokens((ID, IDINSET), (token(ID, DURACION), TOKENSET)) = 
     merge-parallel-consume-tokens(IDINSET,TOKENSET) .

  *** Transiciones
  crl [start] : 
    < O : VProcess | 
      nodes: NODESET, start(ID, IDOUT), 
      flows: FLOWSET, flow(IDOUT, DURACION), 
      tokens: TOKENSET, token(ID, T), 
      Atts 
    > => 
    < O : VProcess | 
      nodes: NODESET, start(ID, IDOUT), 
      flows: FLOWSET, flow(IDOUT, DURACION), 
      tokens: TOKENSET, token(IDOUT, DURACION), 
      Atts 
    > 
    if T = zero .

    crl [end] : 
    < O : VProcess | 
      nodes: NODESET, end(ID, IDIN), 
      flows: FLOWSET, flow(IDIN, DURACION), 
      tokens: TOKENSET, token(IDIN, T), 
      Atts 
    > => 
    < O : VProcess | 
      nodes: NODESET, end(ID, IDIN), 
      flows: FLOWSET, flow(IDIN, DURACION), 
      tokens: TOKENSET, 
      Atts 
    > 
    if T = zero .

    crl [enter-task] : 
    < O : VProcess | 
      nodes: NODESET, task(ID, taskName, IDIN, IDOUT, DURACION, IDSET), 
      flows: FLOWSET, flow(IDIN, DURACION'), 
      tokens: TOKENSET, token(IDIN, T), 
      resources: RESOURCESET, 
      Atts 
    > => 
    < O : VProcess | 
      nodes: NODESET, task(ID, taskName, IDIN, IDOUT, DURACION, IDSET), 
      flows: FLOWSET, flow(IDIN, DURACION'), 
      tokens: TOKENSET, token(ID, DURACION), 
      resources: enter-task-consume-resource(IDSET, RESOURCESET), 
      Atts 
    > 
    if T = zero /\ enter-task-resource-available(IDSET, RESOURCESET) .

    crl [exit-task] : 
    < O : VProcess | 
      nodes: NODESET, task(ID, taskName, IDIN, IDOUT, DURACION, IDSET), 
      flows: FLOWSET, flow(IDOUT, DURACION'), 
      tokens: TOKENSET, token(ID, T), 
      resources: RESOURCESET, 
      Atts 
    > => 
    < O : VProcess | 
      nodes: NODESET, task(ID, taskName, IDIN, IDOUT, DURACION, IDSET), 
      flows: FLOWSET, flow(IDOUT, DURACION'), 
      tokens: TOKENSET, token(IDOUT, DURACION'), 
      resources: exit-task-free(IDSET,RESOURCESET), 
      Atts 
    > 
    if T = zero .

    crl [split-exclusive] : 
    < O : VProcess | 
      nodes: NODESET, split(ID, exclusive, IDIN, (IDOUT, IDSET) ), 
      flows: FLOWSET, flow(IDIN, DURACION), flow(IDOUT, DURACION'),
      tokens: TOKENSET, token(IDIN, T), 
      Atts 
    > => 
    < O : VProcess | 
      nodes: NODESET, split(ID, exclusive, IDIN, (IDOUT, IDSET) ), 
      flows: FLOWSET, flow(IDIN, DURACION), flow(IDOUT, DURACION'),
      tokens: TOKENSET, token(IDOUT, DURACION'), 
      Atts 
    >
    if T = zero .

    crl [split-parallel] : 
    < O : VProcess | 
      nodes: NODESET, split(IDSPLIT, parallel, ID, IDOUTSET), 
      flows: FLOWSET, flow(ID, DURACION),
      tokens: TOKENSET, token(ID, T), 
      Atts 
    > => 
    < O : VProcess | 
      nodes: NODESET, split(IDSPLIT, parallel, ID, IDOUTSET), 
      flows: FLOWSET, flow(ID, DURACION),
      tokens: TOKENSET, split-parallel-gen-token(IDOUTSET, FLOWSET), 
      Atts 
    >
    if T = zero .

    crl [merge-exclusive] : 
    < O : VProcess | 
      nodes: NODESET, merge(IDMERGE, exclusive, (IDINSET, ID), IDOUT), 
      flows: FLOWSET, flow(ID, DURACION), flow(IDOUT, DURACION'),
      tokens: TOKENSET, token(ID, T), 
      Atts 
    > => 
    < O : VProcess | 
      nodes: NODESET, merge(IDMERGE, exclusive, (IDINSET, ID), IDOUT), 
      flows: FLOWSET, flow(ID, DURACION), flow(IDOUT, DURACION'),
      tokens: TOKENSET, token(IDOUT, DURACION'), 
      Atts 
    >
    if T = zero .

    crl [merge-parallel] : 
    < O : VProcess | 
      nodes: NODESET, merge(IDMERGE, parallel, IDINSET, IDOUT), 
      flows: FLOWSET, flow(IDOUT, DURACION),
      tokens: TOKENSET, 
      Atts 
    > => 
    < O : VProcess | 
      nodes: NODESET, merge(IDMERGE, parallel, IDINSET, IDOUT), 
      flows: FLOWSET, flow(IDOUT, DURACION),
      tokens: merge-parallel-consume-tokens(IDINSET,TOKENSET), token(IDOUT, DURACION), 
      Atts 
    >
    if merge-parallel-all-ready(IDINSET, TOKENSET) .

endm 

eof 
